import config
import json
import nacl.utils
import nacl.signing
from nacl.public import PrivateKey, Box
import logging as logger
import sys

class Replica(process):
	dictionary_data;
	
	result_cache;
	operation_result;
	slot_number;
	order_proof;
	result_proof;
	replica_state;

	def setup(client,olympus,currentReplica,prevReplica,nextReplica,headReplica,replica_state,currentReplicaSigningKey,allReplicaVerifyKeysMap):
		print("****************setting up replica start*******************")
		config.main()
		# output("currentReplicaKeys : ",currentReplicaKeys,", allReplicaToPublicKeyMap : ",allReplicaToPublicKeyMap)
		logger.basicConfig(
		format="%(asctime)s [%(threadName)-12.12s] [%(levelname)-5.5s]  %(message)s",
		handlers=[
		logger.FileHandler("{0}/{1}.log".format(config.readProperty("logfile_path"), config.readProperty("logfile_name"))),
		logger.StreamHandler()
		],
		level=logger.DEBUG)
		logger.info("logging for the first time ")
	    # logger.info("*	***********Setting Up replica***********")
		self.client=client
		self.olympus = olympus

		self.currentReplica=currentReplica
		self.prevReplica=prevReplica
		self.nextReplica=nextReplica
		self.currentReplicaSigningKey = currentReplicaSigningKey
		self.allReplicaVerifyKeysMap = allReplicaVerifyKeysMap
		self.headReplica=headReplica
		self.replica_state=replica_state
		self.dictionary_data={}#{'jedi':'luke skywalker','actor':'irfan','criket':'sachin','chupa':'aditya'}	
		self.result_cache={}
		self.operation_result={}
		self.order_proof=[]
		self.result_proof=[]
		if(prevReplica == None):
			self.slot_number = 0

		print("****************setting up replica finished****************")
		
	def main(): pass

	# def receive(msg=('PERFORM_OPERATION',flag,),from_=self.client):
	# 	output("currentReplica: ",self.currentReplica,", prevReplica: ",prevReplica,", nextReplica: ",nextReplica,", client: ",self.client,", flag : ",flag)
	# 	if flag=="FORWARD":
	# 		output("PERFORM Forward shuttle operation")
	# 		if self.nextReplica != None:
	# 			start(self.nextReplica)
	# 			send(('PERFORM_OPERATION',flag,), to=self.nextReplica)
			
	# 		if self.nextReplica == None:
	# 			flag = "REVERSE"
	# 			output("reached the tail node bro!",flag,'reversing the shuttle')
	# 			# send(('PERFORM_OPERATION',flag,), to=self.client)
	# 			send(('PERFORM_OPERATION',flag,), to=self.prevReplica)

	# 	if flag == "REVERSE":
	# 		if self.prevReplica != None:
	# 			send(('REVERSE_SHUTTLE',flag,), to=self.prevReplica)

	# 		if self.prevReplica == None:
	# 			output("reached the head node!",flag)
	
	# def performForwardShuttleOperations(request_id,operation):
		

	def receive(msg=('PERFORM_OPERATION', request_id,operation,), from_=self.client):
		output("Reaching the head node! shuttle initiated:", request_id, operation)
		shuttle=None
		self.slot_number+=1
		self.operation_result[request_id] = self.executeOperation(request_id, operation)
		output("orderr p[rooof  beforeeeeeeeeee****************@@@@@@@@@@@@@##########", self.order_proof)
		
		tupl = self.getResult_Order_Proof(request_id,operation,self.slot_number)
		shuttle = self.updateShuttle(shuttle,tupl)
		self.updateOrder_Result_Proof(shuttle)
		# output("shutttttttllllllllleeeeeee*************", shuttle)

		output("orderr proof ****************@@@@@@@@@@@@@##########", self.result_proof)
		output("orderr proof ****************@@@@@@@@@@@@@##########", self.order_proof)
		send(('SHUTTLE','FORWARD', request_id,shuttle,operation,self.slot_number,), to=self.nextReplica)


	 #message to replca from previous 
	def receive(msg=('SHUTTLE','REVERSE',request_id,result_proof,), from_=self.nextReplica):
		self.cacheResult(request_id)
		if(self.prevReplica == None):
			output('***************YEAH!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
		else:
			send(('SHUTTLE','REVERSE',request_id,result_proof,), to=self.prevReplica)

	 #reverse shuttle
	def receive(msg=('SHUTTLE','FORWARD',request_id,shuttle,operation,slot), from_=self.prevReplica):
		#validate order proof
		if(validateOrderProof(shuttle,operation,slot)):
			output('just before executing')
			self.operation_result[request_id] = self.executeOperation(request_id, operation)
			output('just after executing')
			output("shutttttttll@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@", shuttle)
			slot_number = slot
			output(slot_number)
			output("orderr prooof  beforeeeeeeeeee****************@@@@@@@@@@@@@##########", self.order_proof)

			tupl = self.getResult_Order_Proof(request_id,operation,slot_number)
			shuttle = self.updateShuttle(shuttle,tupl)
			self.updateOrder_Result_Proof(shuttle)
			output("orderr prooof ****************@@@@@@@@@@@@@##########", self.result_proof)
			output("orderr prooof ****************@@@@@@@@@@@@@##########", self.order_proof)

			#validation successful now sending the shuttle forward
			if(self.nextReplica == None):
				self.cacheResult(request_id)
				output('recieved at tail, sending back ')
				orderproof,resultproof =shuttle
				send(('SHUTTLE', resultproof ,), to=self.client)
				send(('SHUTTLE','REVERSE', request_id, resultproof,), to=self.prevReplica)
				output('sent to previous replca from tail')
			else:
				send(('SHUTTLE','FORWARD',request_id,shuttle,operation,slot,), to=self.nextReplica)
				output('sent from replica', self.currentReplica)
		else:
			# NOTE: replica turns itself immutable and sends wedge statement to client with proof od misbehaviour
			output("************************Validating order proof failed at one of the replicas********************")

	#from other replicas to HEAD Replica
	def receive(msg=('RETRANSMISSION_HEAD',requestId,operation,fromReplica,),):
		output("RETRANSMISSION_HEAD request received at HEAD replica : ",currentReplica," from replica : ",fromReplica)
		#NOTE: change it
		if(requestId not in self.result_cache):	
			output("inside requestId in self.result_cache")
			send(("RETRANSMISSION",self.result_cache[requestId],self.currentReplica), to=self.client)
			return;

		timeout = 10
		send(("PERFORM_OPERATION",requestId,operation), to=self.currentReplica)
		if await(some(received(('SHUTTLE','REVERSE',requestId,result_proof,),from_=self.nextReplica))):
			# await(received(('done',)))
			# time.sleep(6)
			output("****************************REACHED HEAD FROM SHUTTLE***************************")
			cacheResult(requestId)
			# send(("PERFORM_OPERATION",requestId,operation), to=self.currentReplica)
			
		elif(timeout(timeout)):
			output("TIMEOUT at Replica : ",self.currentReplica," sending RECONFIGURATION request to Olympus!!!!")

	#from other replicas to HEAD Replica
	def receive(msg=('RETRANSMISSION',requestId,operation,), from_=self.client):
		output("RETRANSMISSION received at ",self.currentReplica,", requestId : ",requestId,", operation : ",operation, ", from client : ",self.client)
		
		if(self.replica_state == 'IMMUTABLE'):
			# if("replica_2" in self.currentReplica):
			msg = "ERROR"
			send(("RETRANSMISSION",msg,self.currentReplica), to=self.client)
		elif(requestId not in self.result_cache):	
			send(("RETRANSMISSION",self.result_cache[requestId],self.currentReplica), to=self.client)

		elif(self.currentReplica != self.headReplica):
			#send request to head
			#self.headReplica
			output("self.currentReplica  : ",self.currentReplica ,", self.headReplica : ",self.headReplica)
			send(("RETRANSMISSION_HEAD",requestId,operation,self.currentReplica),to=self.headReplica)
			timeout=10
			if await(some(received(('SHUTTLE','REVERSE',requestId,result_proof,),from_=self.nextReplica))):
				output("shuttle coming from next replica result_proof : ",result_proof)
				send(("PERFORM_OPERATION",requestId,operation), to=self.currentReplica)
			elif(timeout(timeout)):
				output("timer expired")
		
		#(msg,requestId,operation,replicaId):

	def run():
		await(received('',))

	def executeOperation(request_id,operation):
		output("Dictionary data before performing operation ",self.dictionary_data)
		temp=operation.split('(')
		# print(temp)
		if(temp[0]=="put"):
			tempsplit=operation.split('\'')
			dictionary_data[tempsplit[1]]=tempsplit[3]
			output('put is executeed@@@@@@@@')
			output(dictionary_data)
			return 'ok'

		elif(temp[0] == "append"):
			tempsplit=operation.split('\'')
			if(self.dictionary_data[tempsplit[1]]):	
				self.dictionary_data[tempsplit[1]] = self.dictionary_data[tempsplit[1]] + ' ' + tempsplit[3]
				output('append is executeed@@@@@@@@')
				return 'ok'
			else:
				return 'fail'

		elif(temp[0] == "get"):
			tempsplit=operation.split('\'')
			if(self.dictionary_data[tempsplit[1]]):
				value = self.dictionary_data[tempsplit[1]];
				output('get is executeed@@@@@@@@')	
			else:
				return 'fail'

		elif(temp[0] == "slice"):
			tempsplit=operation.split('\'')
			if(dictionary_data[tempsplit[1]]):
				if (len(dictionary_data[tempsplit[1]])) > int(temp[3]):
					dictionary_data[tempsplit[1]].slice[:int(temp[3])]
					return 'ok'
				else:
					return 'fail'
			else:
				return 'fail'


	def cacheResult(request_id):
		self.result_cache[request_id] = self.operation_result[request_id]

	def validateOrderProof(shuttle,operation,slot):
		orderproof,resultproof = shuttle
		output("this is the order proof ___________________________________",orderproof, "length", len(orderproof))
		output("this is the result proof ___________________________________",resultproof, "length", len(resultproof))
		for i in range(0,len(orderproof)):
			try:
				output("verifying the signature for replica ",i)
				# Create a VerifyKey object from a hex serialized public key
				verify_key = nacl.signing.VerifyKey(self.allReplicaVerifyKeysMap[i], encoder=nacl.encoding.HexEncoder)
				order,result = shuttle
				output("order number",i+1, "from shttle", order[i])
				message = order[i]
				# Check the validity of a message's signature
				# Will raise nacl.exceptions.BadSignatureError if the signature check fails
				verify_key.verify(message)
				output("verified")
			except nacl.exceptions.BadSignatureError:
				output("exception thrown ..................;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;'''''''''''''''''''''''''''''''''''")
				output("key mismatch failed for ", orderproof[i] )
				return False
		output('verification succesffull...................___________________________+++++++++++++++++++++')
		return True

	def updateShuttle(shuttle,tupl):
		output('indide update shuttle:updating it with latest replicas order proof and result proof',tupl)
		order=[]
		result=[]
		orderproof, resultproof=tupl

		# self.order_proof.append((slot_number,operation))
		# self.result_proof.append((self.operation_result[request_id],operation,'encrypted'))

		if(shuttle==None):
			order.append(orderproof)
			result.append(resultproof)
			shuttle=(order,result)
		else:
			shuttle[0].append(orderproof)
			shuttle[1].append(resultproof)

		output('shuttle 99999999999', shuttle)
		return shuttle

	def signMessage(msg):
		# box = Box(currentReplicaPrivateKey,nextReplicaPublicKey)

		# encryptedMsg = box.encrypt(str.encode(msg))
		signedMsg = currentReplicaSigningKey.sign(str.encode(msg))

		#####################
		# encryptedMessage = order_proof
		# if self.nextReplica!=None:
		# 	self.currentReplicaKeys = currentReplicaKeys
		# 	self.allReplicaToPublicKeyMap = allReplicaToPublicKeyMap
		# 	encryptedMessage = encryptMsg(str(order_proof),self.allReplicaToPublicKeyMap[str(self.nextReplica)],self.currentReplicaKeys)
		print("orignal message : ",str(msg),", signedMsg is : ",signedMsg)

		return signedMsg

	def getResult_Order_Proof(request_id,operation,slot_number):
		output("inside function for creating the current tuple")
		order = (slot_number,operation)
		signedOrderProof= signMessage(str(order))

		result = (self.operation_result[request_id],operation,'encrypted')
		signedResultProof = signMessage(str(result))
		tupl = (signedOrderProof,signedResultProof)
		return tupl

	def updateOrder_Result_Proof(shuttle):
		if(shuttle==None):
			output('updating head')
		else:
			oProof, rProof = shuttle
			for i in oProof:
				self.order_proof.append(i)
			for j in rProof:
				self.result_proof.append(j)





