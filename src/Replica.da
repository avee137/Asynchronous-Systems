import config
import json
import nacl.utils
import nacl.signing
from nacl.public import PrivateKey, Box
import logging as logger
import sys
import ast
import time
import os
class Replica(process):
	
	def setup(initHist,configuration,configFilePath,replicas,clients,olympus,currentReplica,prevReplica,nextReplica,headReplica,tailReplica,replica_state,currentReplicaSigningKey,allReplicaVerifyKeysMap,clientVerifyKeys):
		config.config_main(configFilePath)
		logger.basicConfig(
		format="%(asctime)s [%(threadName)-12.12s %(lineno)d] [%(levelname)-5.5s]  %(message)s",
		handlers=[
		logger.FileHandler("{0}/{1}.log".format(config.readProperty("logfile_path"), config.readProperty("logfile_name"))),
		logger.StreamHandler()
		],
		level=logger.INFO)


		print("*************************************************************************")
		logger.info("Replica SETUP done. Clients : "+str(clients)+", Olympus : "+str(olympus)+", Replica : "+str(currentReplica) +", ReplicaState : "+str(replica_state))
		print("*************************************************************************")
		self.replicas= replicas
		self.clients=clients
		self.olympus = olympus
		self.currentReplica=currentReplica
		self.prevReplica=prevReplica
		self.nextReplica=nextReplica
		self.currentReplicaSigningKey = currentReplicaSigningKey
		self.allReplicaVerifyKeysMap = allReplicaVerifyKeysMap
		self.headReplica=headReplica
		self.tailReplica=tailReplica
		self.replica_state=replica_state
		self.clientVerifyKeys = clientVerifyKeys
		#Main Dict object
		self.dictionary_data=initHist#{'jedi':'luke skywalker','actor':'irfan','criket':'sachin','chupa':'aditya'}
		#Result (key=requestId, value = (order_proof,result_proof)	
		self.result_cache={}

		#REMOVING THIS
		# self.operation_result={}
		self.operation_result_internal={}
		self.order_proof=[]
		self.result_proof=[]
		self.checkpointHash={}
		self.History=[]
		#Object to store requestId to (Slot,Operation) pair
		self.requestIdToSoPair = {}
		self.currentCheckPoint=0
		#object to store each clients last result, result statement 	
		self.clientLastResult={}
		if(prevReplica == None):
			self.slot_number = 0

		#counters for failure case
		self.configuration = configuration
		self.counters={}
		for client in clients:
			self.counters[client]={}
			self.counters[client]["directRequestCounter"]=0
			self.counters[client]["forwardRequestCounter"]=0
			self.counters[client]["shuttleCounter"]=0
			self.counters[client]["resultShuttleCounter"]=0
			# self.counters[olympus]["wedge_request"]=0
			# self.counters[olympus]["new_configuration"]=0
			# self.counters["completed_checkpoint"]=0
			# self.counters["checkpoint"]=0
			# self.counters[olympus]["get_running_state"]=0
			# self.counters[olympus]["catch_up"]=0
		self.failureDS = config.readFailures()
		logger.debug("REPLICA SETUP DONE!!")
		
	def main(): pass	

	def incrementCounter(client,counter):
		self.counters[client][counter] =self.counters[client][counter]+1
		
	def updateSlotOperation(request_id,slot,operation):	
		tempSOPair = []
		tempSOPair.append(slot)
		tempSOPair.append(operation)
		self.requestIdToSoPair[request_id] = tuple(tempSOPair)

	def getValidTriggerSet(case):
		validTriggerSet=[]
		if case == "HEAD":
			validTriggerSet.append("client_request")
			validTriggerSet.append("forwarded_request")
			validTriggerSet.append("shuttle")

		if case == "NONHEAD":
			# validTriggerSet.append("client_request")
			validTriggerSet.append("shuttle")
			validTriggerSet.append("result_shuttle")

		if case == "TAIL":
			# validTriggerSet.append("client_request")
			validTriggerSet.append("shuttle")

		return validTriggerSet
	def getUnsignedData(request_id_en,operation_en,client):
		logger.debug("getUnsignedData for request_id_en : "+str(request_id_en))
		request_id=''
		operation=''
		try:
			index =self.clients.index(client)
			verify_key = nacl.signing.VerifyKey(self.clientVerifyKeys[index], encoder=nacl.encoding.HexEncoder)
			tempId = verify_key.verify(request_id_en)
			tempId1 = verify_key.verify(operation_en)
			request_id = tempId.decode("utf-8")
			operation = tempId1.decode("utf-8")
		except  nacl.exceptions.BadSignatureError:
			logger.error("request_id_en: "+request_id_en+", client signed operation and requestID not valid | proof of misbehaviour")
			# callForReconfiguration(self.configuration)

		
		logger.debug("request_id : "+str(request_id)+", unsigned successfully")
		return (request_id,operation)

	#CONTROL FLOW: From (Client to HeadReplica)
	def receive(msg=('PERFORM_OPERATION', request_id_en,operation_en,client), from_=node):
		if(self.replica_state == 'ACTIVE'):
			logger.info("************************FORWARD SHUTTLE***************")
			request_id,operation = getUnsignedData(request_id_en,operation_en,client)	
			self.slot_number+=1
			logger.info("PERFORM_OPERATION at HEAD Replica request_id : "+str(request_id)+", operation : "+str(operation)+", client : "+str(client) +",  slot number: "+str(self.slot_number))
			
			self.counters[client]["directRequestCounter"] =self.counters[client]["directRequestCounter"]+1
			self.counters[client]["shuttleCounter"] =self.counters[client]["shuttleCounter"]+1
			shuttle=None
			
			updateSlotOperation(request_id,self.slot_number,operation)
			self.operation_result_internal[request_id] = config.executeOperation(request_id, operation,self.dictionary_data)

			logger.debug("after execute Operation, result proof: "+ str(self.order_proof))
			tupl = self.getResult_Order_Proof(request_id,operation,self.slot_number)
			shuttle = self.updateShuttle(shuttle,tupl)
			logger.debug("shuttle after update: "+str(shuttle))
			self.UpdateHistory(self.slot_number,operation_en,operation,shuttle, client, request_id)
			self.updateOrder_Result_Proof(shuttle)
			logger.debug("ResultProof: "+str(self.result_proof)+"\n"+"OrderProof: "+str(self.order_proof));
			
			validTriggerSet=getValidTriggerSet("HEAD")
			# validTriggerSet.add("result_shuttle")
			triggerName = checkForPossibleFailure(client,validTriggerSet)
			logger.info("TriggerName Found => "+str(triggerName))
			if(triggerName!=None):
				print("2")
				shuttle=callFailureFunctionBasedOnTrigger(triggerName,shuttle, request_id, slot_number, operation)

			logger.info("PERFORM_OPERATION done at HeadReplica, transfering SHUTTLE to nextReplica : "+str(self.nextReplica))
			orp, rpr = shuttle
			# logger.info("checking for failure injection")
			updateClientsLastResult(rpr,client,self.operation_result_internal[request_id], self.slot_number, request_id)
			# shuttle = change_operation(shuttle, request_id, self.slot_number, operation)
			send(('FORWARD_SHUTTLE', request_id_en,shuttle,operation_en,self.slot_number,client), to=self.nextReplica)
			logger.info("checkpt_interval : " + str(config.readProperty("checkpt_interval")))
			checkpoint_interval = config.readProperty("checkpt_interval")
			if(self.slot_number%checkpoint_interval==0 and self.slot_number - checkpoint_interval > 0):
				
				logger.info("CheckPoint function being called at HEAD")
				executeCheckPointing(self.slot_number - checkpoint_interval)

				# remove this from here
				# if(self.slot_number == 6 and self.currentReplica == self.replicas[1]):
				# 	logger.info("calling for reconfiguration")
				# callForReconfiguration(self.configuration) 
		elif self.replica_state == "IMMUTABLE":
			logger.info("REPLICA is in IMMUTABLE state, wont be performing any functions now")

	 #CONTROL FLOW: From (one o another)
	def receive(msg=('FORWARD_SHUTTLE',request_id_en,shuttle,operation_en,slot,client), from_=self.prevReplica):
		if(self.replica_state == 'ACTIVE'):
			logger.info("************************FORWARD SHUTTLE***************")
			request_id,operation = getUnsignedData(request_id_en,operation_en,client)
			logger.info("PERFORM_OPERATION called at NONHEAD Replica request_id : "+str(request_id)+", operation : "+str(operation)+", client : "+str(client)+", from Replica : "+str(self.prevReplica))
			logger.debug("SHUTTLE : "+str(shuttle)+", SLOT : "+str(slot));
			flow = False
			if(slot>1):
				flow = checkSlotOperation(slot)
				logger.debug("the value for checkSlotOperation is " +str(flow))
			else:
				flow = True
			if(flow):
				if(validateOrderProof(shuttle,operation,slot,request_id,client)):

					self.operation_result_internal[request_id] = config.executeOperation(request_id, operation,self.dictionary_data)
					updateSlotOperation(request_id,slot,operation)
					slot_number = slot
					tupl = self.getResult_Order_Proof(request_id,operation,slot_number)
					shuttle = self.updateShuttle(shuttle,tupl)
					logger.debug("shuttle after update: "+str(shuttle))
					self.UpdateHistory(self.slot_number,operation_en,operation,shuttle, client,request_id)
					self.updateOrder_Result_Proof(shuttle)
					orp,rpr =shuttle
					updateClientsLastResult(rpr,client,self.operation_result_internal[request_id], slot, request_id)
					#validation successful now sending the shuttle forward
					if(self.nextReplica == None):
						
						orderproof,resultproof = shuttle
						# logger.info("justfortest"+str(len(resultproof)))
						self.cacheResult(request_id, resultproof)
						#SENDING result to client
						logger.info("request_id : "+str(request_id)+", operation : "+str(operation)+", client : "+str(client)+'SHUTTLE reached at Tail')
						handleRetransmissionCase()
						# resultproof 	=change_result(resultproof, request_id, operation)
						########################################################################################################
						#CHECKING FOR FAILURE :  SHUTTLE COUNTER : SENDING TO CLIENT
						########################################################################################################
						self.counters[client]["shuttleCounter"] =self.counters[client]["shuttleCounter"]+1
						validTriggerSet=getValidTriggerSet("TAIL")
						triggerName = checkForPossibleFailure(client,validTriggerSet)
						logger.info("TriggerName Found => "+str(triggerName))
						if(triggerName!=None):
							print("3")
							shuttle=callFailureFunctionBasedOnTrigger(triggerName,shuttle, request_id, slot_number, operation)
							orderproof,resultproof=shuttle
						########################################################################################################
						#SENDING RESPONSE TO CLIENT
						logger.info("sending reaponse to client")
						send(('RESULT_FROM_TAIL',request_id, resultproof ,self.operation_result_internal[request_id],self.dictionary_data,self.currentReplica), to=client)

						validation = config.checkForResultConsistency(resultproof, self.operation_result_internal[request_id], self.allReplicaVerifyKeysMap,"replica")
						if(validation):
							logger.info("************************REVERSE SHUTTLE***************")
							#STARTING REVERSE SHUTTLE OPERATIONS
							logger.info('REVERSE_SHUTTLE starting. Forwarding to prevReplica : '+str(self.prevReplica))
							########################################################################################################
							#CHECKING FOR FAILURE : REVERSE SHUTTLE COUNTER : SENDING TO PREVIOUS REPLICA
							########################################################################################################
							self.counters[client]["resultShuttleCounter"] =self.counters[client]["resultShuttleCounter"]+1
							validTriggerSet=[]
							validTriggerSet.append("result_shuttle")#getValidTriggerSet("TAIL")
							triggerName = checkForPossibleFailure(client,validTriggerSet)
							logger.debug("counters : "+str(self.counters))
							logger.info("TriggerName Found => "+str(triggerName))
							if(triggerName!=None):
								print("4")
								shuttle=callFailureFunctionBasedOnTrigger(triggerName,shuttle, request_id, slot_number, operation)
							########################################################################################################
							orderproof,resultproof=shuttle
							
							send(('REVERSE_SHUTTLE', request_id, resultproof, self.operation_result_internal[request_id],client), to=self.prevReplica)

						else:
							logger.error(", request_id : "+str(request_id)+ "    ******************Validating result proof failed at replica : "+str(self.currentReplica))
							callForReconfiguration(self.configuration)
					else:
						self.counters[client]["shuttleCounter"] =self.counters[client]["shuttleCounter"]+1
						validTriggerSet=[]#getValidTriggerSet("NONHEAD")
						validTriggerSet.append("shuttle")
						triggerName = checkForPossibleFailure(client,validTriggerSet)
						logger.debug("counters : "+str(self.counters))
						logger.info("TriggerName Found => "+str(triggerName))
						orderproof,resultproof = shuttle
						if(triggerName!=None):
							print("5")
							shuttle=callFailureFunctionBasedOnTrigger(triggerName,shuttle, request_id, slot_number, operation)
						send(('FORWARD_SHUTTLE',request_id_en,shuttle,operation_en,slot,client), to=self.nextReplica)
				else:
					# NOTE: replica turns itself immutable and sends wedge statement to client with proof od misbehaviour
					logger.error("************************Validating order proof failed at replica : "+str(self.currentReplica)+", request_id : "+str(request_id))
					logger.info("calling for reconfiguration from replica  :: "+str(self.currentReplica))
					callForReconfiguration(self.configuration)
			else:
				logger.error("There is inconsistency in the slots, all previous slot havent been used for execution********************")

		elif self.replica_state=="IMMUTABLE":
			logger.info("REPLICA is in IMMUTABLE state, wont be performing any functions now")

	#######################################################
	def receive(msg=('FORWARD_SHUTTLE_CHECKPOINTING',shuttle,checkpoint), from_=self.prevReplica):
		if(self.replica_state == 'ACTIVE'):
			# request_id,operation = getUnsignedData(request_id_en,operation_en,client)
			logger.info("FORWARD_SHUTTLE_CHECKPOINTING called at NONHEAD Replica  "+", checkpoint : "+str(checkpoint)+", from Replica : "+str(self.prevReplica))
			logger.debug("SHUTTLE : "+str(shuttle)+", checkpoint : "+str(checkpoint));
			checkpointproof = getCheckPointProof()
			shuttle = self.updateCheckpointShuttle(shuttle,checkpointproof,checkpoint)
			logger.debug("checkpoint shuttle after update: "+str(shuttle))
			logger.info("CHECKPOINTING SHUTTLE done at NONHEAD Replica, transfering SHUTTLE to nextReplica : "+str(self.nextReplica))

			# logger.info("checking for failure injection")
			# shuttle = change_operation(shuttle, request_id, self.slot_number, operation)
			
			if(self.nextReplica == None):
				########################################################################################################
				#CHECKING FOR CheckpointConsistency :  SHUTTLE  : 
				########################################################################################################
				logger.info("SHUTTLE : "+str(shuttle)+", checkpoint : "+str(checkpoint)+'CHECKPOINT SHUTTLE reached at Tail')

				validation = checkForCheckProofConsistency(shuttle, self.allReplicaVerifyKeysMap)
				if(validation):
					truncateHistory(checkpoint)
					logger.info('CHECKPOINT_REVERSE_SHUTTLE starting. Forwarding to prevReplica : '+str(self.prevReplica))
					send(('CHECKPOINT_REVERSE_SHUTTLE', shuttle,checkpoint), to=self.prevReplica)
				else:
					logger.error(", checkpoint : "+str(checkpoint)+ "    ******************Validating checkpoint proof failed at replica : "+str(self.currentReplica))
			else:
				send(('FORWARD_SHUTTLE_CHECKPOINTING',shuttle,checkpoint,), to=self.nextReplica)

		elif self.replica_state=="IMMUTABLE":
			logger.info("REPLICA is in IMMUTABLE state, wont be performing any functions now")


	######################################################
	def receive(msg=('CHECKPOINT_REVERSE_SHUTTLE',shuttle,checkpoint,), from_=self.nextReplica):

		if(self.replica_state == 'ACTIVE'):
			logger.info("CHECKPOINT_REVERSE_SHUTTLE reached at replica" +str(self.currentReplica)+",  shuttle : "+str(shuttle)+", checkpoint : "+str(checkpoint)+", from nextReplica : "+str(self.nextReplica))

			validation = checkForCheckProofConsistency(shuttle, self.allReplicaVerifyKeysMap)
			logger.info(" Result from checkpoint  validation is " + str(validation))
			if(validation):
				truncateHistory(checkpoint)
				if(self.prevReplica == None):
					logger.info(" CHECKPOINT  REVERSE SHUTTLE reached at HEAD")
				else:
					logger.info("checkpoint : "+str(checkpoint)+", after caching result, forwarding to prevReplica : "+str(self.prevReplica))
					send(('CHECKPOINT_REVERSE_SHUTTLE', shuttle,checkpoint,), to=self.prevReplica)
			else:
				logger.error("the validation failed at" + str(self.currentReplica))
				logger.error("************************Validating Check pointing proof failed at replica : "+str(self.currentReplica))

		elif self.replica_state=="IMMUTABLE":
			logger.info("REPLICA is in IMMUTABLE state, wont be performing any functions now")

	 #message to replca from previous 
	def receive(msg=('REVERSE_SHUTTLE',request_id,result_proof, res,client,), from_=self.nextReplica):
		
		# incrementCounter(client,"resultShuttleCounter")
		if(self.replica_state == 'ACTIVE'):
			logger.info("************************REVERSE SHUTTLE***************")
			self.counters[client]["resultShuttleCounter"] =self.counters[client]["resultShuttleCounter"]+1
			logger.info("REVERSE_SHUTTLE reached at replica request_id : "+str(request_id)+", client : "+str(client)+", from nextReplica : "+str(self.nextReplica))
			validation = config.checkForResultConsistency(result_proof, res, self.allReplicaVerifyKeysMap,"replica")
			logger.info("the result from validation is " + str(validation))
			if(validation):
				
				self.cacheResult(request_id, result_proof)
				if(self.prevReplica == None):
					logger.info("SHUTTLE reached at HEAD")
				else:
					validTriggerSet=[]
					validTriggerSet.append("result_shuttle")
					triggerName = checkForPossibleFailure(client,validTriggerSet)
					logger.debug("counters : "+str(self.counters))
					logger.info("TriggerName Found => "+str(triggerName))
					if(triggerName!=None):
						shuttle=(None,result_proof)
						slot_number=self.requestIdToSoPair[request_id][0]
						operation=self.requestIdToSoPair[request_id][1]
						print("1")
						shuttle=callFailureFunctionBasedOnTrigger(triggerName,shuttle, request_id, slot_number, operation)
						orderproof,result_proof= shuttle
					logger.info("request_id : "+str(request_id)+", after caching result, forwarding to prevReplica : "+str(self.prevReplica))

					send(('REVERSE_SHUTTLE',request_id,result_proof, res,client,), to=self.prevReplica)
			else:
				logger.error("the validation failed at" + str(self.currentReplica))
				logger.error("************************Validating order proof failed at replica : "+str(self.currentReplica)+", request_id : "+str(request_id))
		elif self.replica_state=="IMMUTABLE":
			logger.info("REPLICA is in IMMUTABLE state, wont be performing any functions now")

	#FROM NON-HEAD Replicas to HEAD Replica for Retransmission case
	def receive(msg=('RETRANSMISSION_HEAD',requestId_en,operation_en,fromReplica,client),):
		if(self.replica_state == 'ACTIVE'):
			logger.info("RETRANSMISSION_HEAD to HEAD Replica")
			requestId,operation = getUnsignedData(requestId_en,operation_en,client)
			self.counters[client]["forwardRequestCounter"] =self.counters[client]["forwardRequestCounter"]+1
			logger.info("RETRANSMISSION_HEAD request received from"+str(fromReplica))
			timeout = config.readProperty("head_timeout")
			#NOTE: change it to  : if(requestId in self.result_cache):	
			if(requestId in self.result_cache):	
				logger.info("RequestId found inside the cache. Returning response to client : "+client+", requestId : "+str(requestId))
				send(("RETRANSMISSION",self.result_cache[requestId],self.currentReplica), to=client)
				return;
			#HEAD has already started operation for the first request sent by other 
			#replicas(including head) in case it does not recognize the operation
			if((requestId in self.requestIdToSoPair) and (requestId not in self.result_cache)):
				logger.info("Result shuttle is yet to receive at the head, waiting for it!! fromReplica : "+str(fromReplica))
				if await(some(received(('REVERSE_SHUTTLE',requestId,result_proof,res,),from_=self.nextReplica),has= (requestId in self.result_cache))):
					logger.info("REACHED HEAD FROM SHUTTLE & RETRANSMISSION COMPLETE")
				elif(timeout(timeout)):
					logger.info("TIMEOUT at Replica : "+str(self.currentReplica)+" sending RECONFIGURATION request to Olympus!!!!")		
			else:
				#PERFORM Operation for FORWARD_SHUTTLE only once and stop for all other Replicas
				logger.info("Operation is not recognized at HeadReplica. requestId : "+str(requestId)+", operation : "+str(operation))
				send(("PERFORM_OPERATION",requestId_en,operation_en), to=self.headReplica)
				if(timeout(timeout)):
					logger.info("TIMEOUT at Replica : "+str(self.currentReplica)+" sending RECONFIGURATION request to Olympus!!!!")	
		elif self.replica_state=="IMMUTABLE":
			logger.info("REPLICA is in IMMUTABLE state, wont be performing any functions now")	
			

	#FROM Clients To Replicas
	def receive(msg=('RETRANSMISSION',requestId_en,operation_en,client,), from_=self.clients):
		if(self.replica_state == 'ACTIVE'):
			requestId,operation = getUnsignedData(requestId_en,operation_en,client)
			logger.info("RETRANSMISSION received at "+str(self.currentReplica)+", requestId : "+str(requestId)+", operation : "+str(operation)+ ", from client : "+str(client))
			if(self.replica_state == 'IMMUTABLE'):
				# if("replica_2" in self.currentReplica):
				logger.info("Replica is in IMMUTABLE state. Returning ERROR to clients")
				send(("RETRANSMISSION","ERROR",self.currentReplica), to=client)
			#TEMPORARILY MADE NOT HERE, TO ALLOW NEXT CASE. REVERT IT TO : elif(requestId in self.result_cache):	
			elif(requestId in self.result_cache):	
				logger.info("RequestId found in replica cache. Returning to client : "+str(client))
				#TODO NOTE Handle Shuttle 
				send(("RETRANSMISSION",self.result_cache[requestId],self.currentReplica), to=client)

			else:#(self.currentReplica != self.headReplica):
				#send request to head
				#self.headReplica
				logger.info("Operation is not recognized. Forwarding to HEAD REPLICA. From currentReplica : "+ str(self.currentReplica)+", client : "+str(client))
				send(("RETRANSMISSION_HEAD",requestId_en,operation_en,self.currentReplica,client),to=self.headReplica)
				
				timeout=config.readProperty("nonhead_timeout")
				#check if the current replica is a tailReplica, if yes, it will get result shuttle from prevReplica else
				#all other shuttle will receive results from nextReplica
				slot=int()
				shuttle=[]
				# if ((self.currentReplica==self.tailReplica) and await(some(received(('SHUTTLE','FORWARD',request_id,shuttle,operation,slot),from_=self.prevReplica)))) or await(some(received(('SHUTTLE','REVERSE',requestId,result_proof,),from_=self.nextReplica),has=requestId in self.result_cache)):
				
				if (self.currentReplica==self.tailReplica):
					if(await(some(received(('FORWARD_SHUTTLE',request_id,shuttle,operation,slot),from_=self.prevReplica)))):
						logger.info("in retransmission unrecognised request. Shuttle reached to tail node : "+str(result_proof)+", sending to client : "+str(client))
						send(('RETRANSMISSION', self.result_cache[requestId] ,self.currentReplica), to=client)
					elif(timeout(timeout)):
						logger.info("timer expired at tail replica : "+str(self.currentReplica))
				else:
					if await(some(received(('REVERSE_SHUTTLE',requestId,result_proof,res,),from_=self.nextReplica),has=requestId in self.result_cache)):
						logger.info("shuttle coming from next replica result_proof : "+str(result_proof)+", sending to client : "+str(client))
						send(('RETRANSMISSION', self.result_cache[requestId] ,self.currentReplica), to=client)
					elif(timeout(timeout)):
						logger.info("timer expired at non head replica : "+str(self.currentReplica))
						#TODO RECONFIGURATION
		elif self.replica_state=="IMMUTABLE":
			logger.info("REPLICA is in IMMUTABLE state, wont be performing any functions now")	


	def receive(msg=('WEDGE_REQUEST_STATEMENT',), from_=self.olympus):
		logger.info("************Wedge Statement requested from Olympus******** Going into Immutable state")
		if(self.currentReplica == self.replicas[2]):
			print("waiting for sleep")
			# time.sleep(5)
		self.replica_state = "IMMUTABLE"
		# check if the replica is in immutable in all other cases
		send(('WEDGE_STATEMENT',self.currentCheckPoint,self.History,), to=self.olympus)
		# send(('WEDGE_STATEMENT',), to=self.olympus)

	def receive(msg=('CATCH_UP',orders,), from_=self.olympus):
		logger.info("************ CATCH_UP requested from Olympus******** Going to execute the orders ")
		# check if the replica is in immutable in all other cases
		print ("length of incoming order", orders, len(orders))
		if len(orders)>0:
			for i in  range(len(orders)):
				slot_CU,operation_CU, client_CU, req_CU = orders[i]
				logger.info("Executing the order for slot : " + str(slot_CU))
				oper = config.getUnsignedData(operation_CU,client_CU,self.clientVerifyKeys,self.clients)
				result =config.executeOperation(req_CU,oper,self.dictionary_data)
				ehash = config.calculateHash(result)
				resulpr = (result,oper,ehash,req_CU)
				# logger.info("Client lasr statement perepared : " + str(client_CU)+ " ::::"+str(resultpr))
				logger.info("Order Executed the order for slot : " + str(slot_CU))
				#do we need request Id also
				# self.self.requestIdToSoPair[request_id][0]
				self.clientLastResult[client_CU] = resulpr
				logger.info(" Client updated with the last result statement")
		dict_hash = config.calculateHash(str(self.dictionary_data))
		send(('CAUGHT_UP',dict_hash,self.clientLastResult,), to=self.olympus)
		logger.info("************ CAUGHT_UP sent to Olympus******** ")

	def receive(msg=('GET_RUNNING_STATE',), from_=self.olympus):
		logger.info("************ FINAL GET_RUNNING_STATE requested from Olympus********")
		# dict_hash = config.calculateHash(str(self.dictionary_data))
		send(('RUNNING_STATE',self.dictionary_data,), to=self.olympus)
		logger.info("************FINAL_RUNNING_STATE sent to Olympus********")
		
	def receive(msg=('KILLING_REPLICAS',), from_=self.olympus):
		logger.info("Killing Myself: This is replica: " + str(self.currentReplica))
		# end(self.currentReplica)
		os._exit(-1)
		logger.info("exited")

	def run():
		await(received('',))


	def cacheResult(request_id, resultproof):
		logger.info("caching result for request_id : "+str(request_id))
		self.result_cache[request_id] = resultproof

	def validateOrderProof(shuttle,operation,slot,request_id,client):
		logger.info("request_id : "+str(request_id)+", operation : "+str(operation)+", client : "+str(client)+", validateOrderProof")
		if(shuttle == None):
			return False
		logger.debug("validating order proofs, SHUTTLE is not empty...")
		order,result = shuttle
		flag = True
		for i in range(0,len(order)):
			try:
				# Create a VerifyKey object from a hex serialized public key
				verify_key = nacl.signing.VerifyKey(self.allReplicaVerifyKeysMap[i], encoder=nacl.encoding.HexEncoder)
				logger.debug("order number"+str(i+1)+ "from shttle : "+ str(order[i]))
				message = order[i]
				# Check the validity of a message's signature
				# Will raise nacl.exceptions.BadSignatureError if the signature check fails
				Tuple = verify_key.verify(message)
				orderTuple = ast.literal_eval(Tuple.decode("utf-8"))
				# print("orderTuple as of now "+str(orderTuple)+" "+str(slot)+str(operation))
				logger.debug("validating this slot pair of orderproodf "+str())
				if(orderTuple != (slot,operation)):
					flag=False
					break
				logger.debug("verified")
			except nacl.exceptions.BadSignatureError:
				logger.error("key mismatch failed for " + str(order[i]))
				flag = False

		if(flag):
			logger.info("validation success")
		else:
			logger.error("validation failed")
		return flag

	# def validateResultProof(resultproof):
	# 	for i in range(0,len(resultproof)):
	# 		length = len(resultproof)
	# 		try:
	# 			logger.debug("12345678908765432123456789876543234567987654323456789876543234567890987654", resultproof)
	# 			# Create a VerifyKey object from a hex serialized public key
	# 			verify_key = nacl.signing.VerifyKey(self.allReplicaVerifyKeysMap[1], encoder=nacl.encoding.HexEncoder)
	# 			logger.debug("result number",i+1, "from result proof", resultproof[length-i-1])
	# 			message = resultproof[length-i-1]
	# 			# Check the validity of a message's signature
	# 			# Will raise nacl.exceptions.BadSignatureError if the signature check fails
	# 			result = verify_key.verify(message)

	# 			logger.debug("verified")
	# 			actualResult = result.decode("utf-8")
	# 		except nacl.exceptions.BadSignatureError:
	# 			logger.error("key mismatch failed for ", resultproof[length-i-1])
	# 			return (False,None)
	# 	logger.info("validateResultProof. SUCCESSFULL!! ")
	# 	return (True,actualResult)

	def updateShuttle(shuttle,tupl):
		logger.debug("updateShuttle at Replica : "+str(self.currentReplica))
		order=[]
		result=[]
		orderproof, resultproof=tupl

		# self.order_proof.append((slot_number,operation))
		# self.result_proof.append((self.operation_result_internal[request_id],operation,'encrypted'))

		if(shuttle==None):
			order.append(orderproof)
			result.append(resultproof)
			shuttle=(order,result)
		else:
			shuttle[0].append(orderproof)
			shuttle[1].append(resultproof)

		return shuttle

	def signMessage(msg):
		signedMsg = currentReplicaSigningKey.sign(str.encode(msg))
		logger.debug("orignal message : "+str(msg)+", signedMsg : "+str(signedMsg))
		return signedMsg

	def getResult_Order_Proof(request_id,operation,slot_number):
		logger.debug("inside getResult_Order_Proof function for creating the current tuple")
		order = (slot_number,operation)
		signedOrderProof= signMessage(str(order))
		encryptedHash = config.calculateHash(self.operation_result_internal[request_id])
		result = (self.operation_result_internal[request_id],operation,encryptedHash)
		signedResultProof = signMessage(str(result))
		tupl = (signedOrderProof,signedResultProof)
		# tupl = (str(order),str(result))
		return tupl

	def updateOrder_Result_Proof(shuttle):
		logger.info("updating OrderProof and ResultProof !!")
		if(shuttle==None):
			logger.info('Updating HEAD Replica')
		else:
			oProof, rProof = shuttle
			for i in oProof:
				self.order_proof.append(i)
			for j in rProof:
				self.result_proof.append(j)

		# logger.info("the updated orderproof"+str(self.order_proof))
	def checkSlotOperation(slot):
		if(self.order_proof==None or len(self.order_proof)==0 ):
			return False
		index =self.replicas.index(self.currentReplica)
		verify_key = nacl.signing.VerifyKey(allReplicaVerifyKeysMap[index], encoder=nacl.encoding.HexEncoder)
		# logger.debug("result number",i+1, "from result proof", resultproof[length-i-1])
		message = self.order_proof[len(self.order_proof)-1]
		# Check the validity of a message's signature
		# Will raise nacl.exceptions.BadSignatureError if the signature check fails
		result = verify_key.verify(message)

		# # logger.debug("verified")
		actualResult = ast.literal_eval(result.decode("utf-8"))
		s,o =actualResult
		if(s == slot - 1):
			logger.debug("the slots are consistent")
			return True
		else:
			logger.debug("there is inconsistency among slots")
			return False

	
	def handleRetransmissionCase():
		retransmission_case_replica_sleep_time=config.readProperty('retransmission_case_replica_sleep_time')
		if(retransmission_case_replica_sleep_time > 0):
			logger.info("retransmission flag ON. Sleeping for "+str(retransmission_case_replica_sleep_time))
			time.sleep(retransmission_case_replica_sleep_time)

	def callFailureFunctionBasedOnTrigger(triggerName,shuttle, request_id, slot_number, operation):
		logger.info("request_id : "+str(request_id)+", operation : "+str(operation)+", triggerName : "+str(triggerName)+", callFailureFunctionBasedOnTrigger")

		if(triggerName == "change_operation"):
			return change_operation(shuttle, request_id, slot_number, operation)
		elif(triggerName == "change_result"):
			return change_result(shuttle, request_id, operation)
		if(triggerName == "drop_result_stmt"):
			return drop_result_stmt(shuttle)
		if(triggerName == "invalid_order_sig"):
			return invalid_order_sig(shuttle)
		if(triggerName == "invalid_result_sig"):
			return invalid_result_sig(shuttle, request_id, operation)

	# def checkForPossibleFailure(client,validTriggerSet):
	# 	logger.info("CheckForPossibleFailure : "+str(self.counters)+", self.failureDS : "+str(self.failureDS)+", client : "+str(client))
	# 	if(self.failureDS == None or len(self.failureDS)==0) :
	# 		return
	# 	replicaIndex = self.replicas.index(self.currentReplica)
	# 	currentConfiguration = self.configuration
	# 	failureDsReplicaDict = self.failureDS[currentConfiguration]["replica"]
	# 	logger.debug("the dictionary: ",failureDsReplicaDict)
	# 	if(replicaIndex not in failureDsReplicaDict):
	# 		return None
	# 	print("ended up here")
	# 	failureLists = self.failureDS[currentConfiguration]["replica"][replicaIndex]
	# 	for obj in failureLists:
	# 		triggerName = obj["triggerName"]
	# 		clientObj = obj["client"]
	# 		if(clientObj == None):
	# 			logger.debug("clientObj is empty")
	# 			return None
	# 		messageNumber=obj["messageNumber"]
	# 		triggerFailure=obj["triggerFailure"]
	# 		if(clientObj != self.clients.index(client)):
	# 			logger.debug("client index is different")
	# 			continue
	# 		if(triggerName not in validTriggerSet):
	# 			logger.debug("trigger name is not in the set:" +str(validTriggerSet))
	# 			continue
	# 		logger.debug("reached here!")
	# 		if(self.counters[client]["directRequestCounter"] == messageNumber and triggerName=="client_request"):
	# 			return triggerFailure
	# 		elif(self.counters[client]["forwardRequestCounter"] == messageNumber and triggerName=="forwarded_request"):
	# 			return triggerFailure
	# 		elif(self.counters[client]["shuttleCounter"] == messageNumber and triggerName=="shuttle"):
	# 			return triggerFailure
	# 		elif(self.counters[client]["resultShuttleCounter"] == messageNumber and triggerName=="result_shuttle"):
	# 			return triggerFailure
	# 		logger.debug("before returning")
	# 	return None

	def checkForPossibleFailure(client,validTriggerSet):
		logger.info("CheckForPossibleFailure : "+str(self.counters)+", self.failureDS : "+str(self.failureDS)+", client : "+str(client))
		if(self.failureDS == None or len(self.failureDS)==0) :
			print("CheckForPossibleFailure returning 1")
			return None
		replicaIndex = self.replicas.index(self.currentReplica)
		print("1. ended up here")
		currentConfiguration = self.configuration
		if(currentConfiguration not in self.failureDS):
			print("CheckForPossibleFailure returning 1.1")
			return None
		failureDsReplicaDict = self.failureDS[currentConfiguration]["replica"]
		print("2. ended up here")
		logger.debug("the dictionary: ",failureDsReplicaDict)
		if(replicaIndex not in failureDsReplicaDict):
			print("CheckForPossibleFailure returning 2")
			return None
		print("3 ended up here")
		failureLists = self.failureDS[currentConfiguration]["replica"][replicaIndex]
		print("4. ended up here")
		for obj in failureLists:
			triggerName = obj["triggerName"]
			clientObj = obj["client"]
			if(clientObj == None):
				print("CheckForPossibleFailure returning 3")
				return None
			messageNumber=obj["messageNumber"]
			triggerFailure=obj["triggerFailure"]
			if(clientObj != self.clients.index(client)):
				logger.debug("client index is different")
				continue
			if(triggerName not in validTriggerSet):
				logger.debug("trigger name is not in the set:" +str(validTriggerSet))
				continue
			logger.debug("reached here!")
			if(self.counters[client]["directRequestCounter"] == messageNumber and triggerName=="client_request"):
				return triggerFailure
			elif(self.counters[client]["forwardRequestCounter"] == messageNumber and triggerName=="forwarded_request"):
				return triggerFailure
			elif(self.counters[client]["shuttleCounter"] == messageNumber and triggerName=="shuttle"):
				return triggerFailure
			elif(self.counters[client]["resultShuttleCounter"] == messageNumber and triggerName=="result_shuttle"):
				return triggerFailure
			logger.debug("before returning")
		print("CheckForPossibleFailure returning 4")
		return None


	def change_operation(shuttle, requestId, slot, operation ):
		#just before tsending the shuttle
		logger.info("Change operation called with shuttle, requestId: "+ str(requestId) +"operation : "+ str(operation))
		order, result = shuttle
		lorder = len(order)
		lresult = len(result)
		# print("length of oreder"+str(len(order)))
		order = order[0:lorder-1]
		# print("length of oreder"+str(len(order)))
		result =  result[0:lresult-1]
		orderStmt = (slot, "get('x')")
		resultStmt = (operation_result_internal[requestId], operation, config.calculateHash(operation_result_internal[requestId]))
		signedOrderProof= signMessage(str(orderStmt))
		signedResultProof = signMessage(str(resultStmt))
		order.append(signedOrderProof)
		# print("length of oreder"+str(len(order)))
		result.append(signedResultProof)
		shuttle = (order,result)
		logger.info("change shuttle"+ str(shuttle))
		slot , op,rep_op, client, req_id , order_p = self.History[len(self.History)-1]
		self.History = self.History[0:len(self.History)-1]
		tempHist = (slot, op,"get('x')" , client ,req_id,order_p )
		self.History.append(tempHist)

		return shuttle

	def change_result(shuttle, requestId, operation):

		logger.info("Change result called with resultproof" + "  requestId: "+ str(requestId) +"operation : "+ str(operation))
		order, resultproof = shuttle
		# lorder = len(order)
		lresult = len(resultproof)
		print("length of resultproof"+str(len(resultproof)))
		# orderStmt = (slot, "get('x')")
		resultStmt = (operation_result_internal[requestId], operation, config.calculateHash('OKayy'))
		print("this is the bugged statement : ",resultStmt)
		# signedOrderProof= signMessage(str(orderStmt)
		signedResultProof = signMessage(str(resultStmt))
		resultproof =  resultproof[0:lresult-1]
		# order[lorder] = signedOrderProof
		resultproof.append(signedResultProof)
		return (order, resultproof)
		# shuttle = (order,signedResultProof)
		# for i in Res

	def drop_result_stmt(shuttle):
		order, result = shuttle
		result = result[1:]
		return (order,result)

	def crash():
		logger.info("Inside the crash failure, killing the replica" + str(self.currentReplica))
		os_exit(-1)

	def truncate_history(n):
		self.History = self.History[:len(self.History)- n]

	def sleep(time): 
		time.sleep(time)

	def drop():
		#you will have to check where all this can be usd and put a flag there
		pass 
	def extra_op():
		executeOperation("not required here", put('a','a'), self.dictionary_data)

	def invalid_result_sig(shuttle, requestId, operation):
		logger.info("invalid_result_sig function called ")
		order, result = shuttle
		lproof = len(result)
		resultStmt = result[lproof-1]
		# resultStmt = (operation_result_internal[requestId], operation, config.calculateHash(str(operation_result_internal[requestId])))

		# NewKey = currentReplicaSigningKey
		signedlist = list(resultStmt)
		signedlist[0] = (signedlist[0] + 1) % 256
		newsigned=bytes(signedlist)
		invalid_signed = nacl.signing.SignedMessage._from_parts(resultStmt._signature, resultStmt._message, newsigned)
		# signedMsg = newsigned.sign(str.encode(str(resultStmt)))
		result[lproof-1] = invalid_signed
		# print("length of oreder"+str(len(order)))
		# result.append(signedResultProof)
		shuttle = (order,result)
		return shuttle


	def invalid_order_sig(shuttle):
		logger.info("invalid_order_sig function called  at replica")
		order, result = shuttle
		lorder = len(order)
		orderstmt = order[lorder-1]
		signedlist = list(orderstmt)
		signedlist[0] = (signedlist[0] + 1) % 256
		newsigned=bytes(signedlist)

		invalid_signed = nacl.signing.SignedMessage._from_parts(orderstmt._signature, orderstmt._message, newsigned)
		order[lorder-1] =invalid_signed
		# print("length of oreder"+str(len(order)))
		# result.append(signedResultProof)
		shuttle = (order,result)
		logger.info("change shuttle"+ str(shuttle))
		slot , op,rep_op, client, req_id , order_p = self.History[len(self.History)-1]
		self.History = self.History[0:len(self.History)-1]
		tempHist = (slot, op, rep_op,client ,req_id,order )
		self.History.append(tempHist)

		return shuttle

	def drop_checkpt_stmts(chkStmt, t):
		chkStmt = chkStmt[t+2:]

	def increment_slot(s):
		s = s+1

	def executeCheckPointing(checkpoint):
		logger.debug("inside executeCheckPointing function for creating the current checkpoint")
		checkpointproof = getCheckPointProof()
		shuttle=[]
		# tupl = self.getResult_Order_Proof(request_id,operation,self.slot_number)
		shuttle = self.updateCheckpointShuttle(shuttle,checkpointproof,checkpoint)
		logger.debug("checkpoint shuttle after update: "+str(shuttle))
		logger.info("CHECKPOINTING SHUTTLE done at HeadReplica, transfering SHUTTLE to nextReplica : "+str(self.nextReplica))

		# logger.info("checking for failure injection")
		# shuttle = change_operation(shuttle, request_id, self.slot_number, operation)
		send(('FORWARD_SHUTTLE_CHECKPOINTING',shuttle,checkpoint,), to=self.nextReplica)

	def updateCheckpointShuttle(shuttle,checkpointproof,slot):
		logger.debug("updateCheckpointShuttle at Replica : "+str(self.currentReplica))

		if(len(shuttle)==0):
			# shuttle.append(slot)
			shuttle.append(checkpointproof)
			# shuttle=(order,result)
		else:
			shuttle.append(checkpointproof)
			# shuttle[1].append(resultproof)

		return shuttle

	def getCheckPointProof():
		logger.debug("inside executeCheckPointing function for creating the current checkpoint")
		running_state = config.calculateHash(str(self.dictionary_data))
		# checkPtProof = (slot_num,running_state)
		signedCheckPtProof= signMessage(str(running_state))
		return signedCheckPtProof

	def checkForCheckProofConsistency(shuttle, allReplicaVerifyKeysMap):
		logger.info("Validating CheckPoint Proof function called  with shuttle : "+str(shuttle))
		hashValues=[]
		if(len(shuttle)==0):
			return False
		print("okay till here")
		if(len(shuttle) != len(self.replicas)):
			print("its not okay  till here")
			return False
		print("okay till here")
		for i in range(0,len(shuttle)):
			try:
				# Create a VerifyKey object from a hex serialized public key
				verify_key = nacl.signing.VerifyKey(allReplicaVerifyKeysMap[i], encoder=nacl.encoding.HexEncoder)
				# logger.debug("result number",i+1, "from result proof", resultproof[length-i-1])
				message = shuttle[i]
				# Check the validity of a message's signature
				# Will raise nacl.exceptions.BadSignatureError if the signature check fails
				result = verify_key.verify(message)

				# logger.debug("verified")
				actualResult = ast.literal_eval(result.decode("utf-8"))
			except nacl.exceptions.BadSignatureError:
				print("there is an exception")
				# logger.error("key mismatch failed for ", resultproof[length-i-1])
				return False
			hashValues.append(actualResult)
		flag = True
		for i in range(len(hashValues)):
			if(hashValues[0] != hashValues[i]):
				flag = False
				return False
			else:
				continue
		return flag

	def truncateHistory(checkpoint):
		logger.info("TRUNCATE HISTORY function called at replica  : " +str(self.currentReplica))
		logger.debug("checkpoint number : " + str(checkpoint))
		index =self.replicas.index(self.currentReplica)
		# print("index:", index)
		logger.debug("history:" + str(self.History))
		logger.debug("history length before truncation:" + str(len(self.History)))
		# print("history 1:",self.History[0][0])
		for index in range(len(self.History)):
			# print("runnig the loop for ", self.History[index][0])
			if(self.History[index][0] > checkpoint):
				break;
		print("history is being truncated at this slot", self.History[index][0])
		self.History = self.History[index:]
		logger.info("history length after truncation:" + str(len(self.History)))
		self.checkpointHash[checkpoint]= config.calculateHash(str(self.dictionary_data))
		self.currentCheckPoint = checkpoint


	def UpdateHistory(slot,op,rep_op,shuttle, client,request_id):
		temp = []
		order, res = shuttle
		temp.append(slot)	
		temp.append(op)
		temp.append(rep_op)
		temp.append(client)
		temp.append(request_id)
		temp.append(order)
		self.History.append(temp)

	def updateClientsLastResult(rProof,client,res, slot, req):
		tupl = (slot,rProof,res, req)
		self.clientLastResult[client] = tupl
		logger.debug(" client dictionary after updatinf last result is :" + str(self.clientLastResult))

	def callForReconfiguration(configuration):
		logger.debug("olympus::", self.olympus)
		logger.info("reconfiguration called from Replcia")
		self.replica_state="ACTIVE"
		send(('RECONFIGURATION_REQUEST',configuration,), to=self.olympus)





