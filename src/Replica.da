import config
import json
import nacl.utils
import nacl.signing
from nacl.public import PrivateKey, Box
import logging as logger
import sys
import ast
import time
class Replica(process):
	
	def setup(configFilePath,replicas,clients,olympus,currentReplica,prevReplica,nextReplica,headReplica,tailReplica,replica_state,currentReplicaSigningKey,allReplicaVerifyKeysMap):
		config.config_main(configFilePath)
		logger.basicConfig(
		format="%(asctime)s [%(threadName)-12.12s] [%(levelname)-5.5s]  %(message)s",
		handlers=[
		logger.FileHandler("{0}/{1}.log".format(config.readProperty("logfile_path"), config.readProperty("logfile_name"))),
		logger.StreamHandler()
		],
		level=logger.INFO)
		logger.info("Replica SETUP. currentReplica : "+str(currentReplica)+", clients : "+str(clients)+", olympus : "+str(olympus)+", replica_state : "+str(replica_state))
	    # logger.info("*	***********Setting Up replica***********")
		self.replicas= replicas
		self.clients=clients
		self.olympus = olympus
		self.currentReplica=currentReplica
		self.prevReplica=prevReplica
		self.nextReplica=nextReplica
		self.currentReplicaSigningKey = currentReplicaSigningKey
		self.allReplicaVerifyKeysMap = allReplicaVerifyKeysMap
		self.headReplica=headReplica
		self.tailReplica=tailReplica
		self.replica_state=replica_state
		#Main Dict object
		self.dictionary_data={}#{'jedi':'luke skywalker','actor':'irfan','criket':'sachin','chupa':'aditya'}
		#Result (key=requestId, value = (order_proof,result_proof)	
		self.result_cache={}

		#REMOVING THIS
		# self.operation_result={}
		self.operation_result_internal={}
		self.order_proof=[]
		self.result_proof=[]
		#Object to store requestId to (Slot,Operation) pair
		self.requestIdToSoPair = {}

		if(prevReplica == None):
			self.slot_number = 0

		#counters for failure case
		
		self.counters={}
		for client in clients:
			self.counters[client]={}
			self.counters[client]["directRequestCounter"]=0
			self.counters[client]["forwardRequestCounter"]=0
			self.counters[client]["shuttleCounter"]=0
			self.counters[client]["resultShuttleCounter"]=0
		
		self.failureDS = config.readFailures()
		logger.debug("REPLICA SETUP DONE!!")
		
	def main(): pass	

	def incrementCounter(client,counter):
		self.counters[client][counter] =self.counters[client][counter]+1
		
	def updateSlotOperation(request_id,slot,operation):	
		tempSOPair = []
		tempSOPair.append(slot)
		tempSOPair.append(operation)
		self.requestIdToSoPair[request_id] = tuple(tempSOPair)

	def getValidTriggerSet(case):
		validTriggerSet=[]
		if case == "HEAD":
			validTriggerSet.append("client_request")
			validTriggerSet.append("forwarded_request")
			validTriggerSet.append("shuttle")

		if case == "NONHEAD":
			# validTriggerSet.append("client_request")
			validTriggerSet.append("shuttle")
			validTriggerSet.append("result_shuttle")

		if case == "TAIL":
			# validTriggerSet.append("client_request")
			validTriggerSet.append("shuttle")

		return validTriggerSet


	#CONTROL FLOW: From (Client to HeadReplica)
	def receive(msg=('PERFORM_OPERATION', request_id,operation,client), from_=node):
		#incrementing direct request counter from client 
		# if("client" in node):
		# logger.info("inside the if loop")
		self.counters[client]["directRequestCounter"] =self.counters[client]["directRequestCounter"]+1
		self.counters[client]["shuttleCounter"] =self.counters[client]["shuttleCounter"]+1
		shuttle=None
		self.slot_number+=1
		logger.info("PERFORM_OPERATION Called from client : "+str(client)+", request_id: "+str(request_id)+", operation: "+str(operation)+", slot: "+ str(self.slot_number)+ "	at replica : "+str(self.currentReplica))
		# self.operation_result[request_id] = self.executeOperation(request_id, operation)
		updateSlotOperation(request_id,self.slot_number,operation)
		self.operation_result_internal[request_id] = self.executeOperation(request_id, operation)

		logger.debug("After execute Operation, result proof: "+ str(self.order_proof))
		tupl = self.getResult_Order_Proof(request_id,operation,self.slot_number)
		shuttle = self.updateShuttle(shuttle,tupl)
		logger.debug("shuttle after update: "+str(shuttle))
		self.updateOrder_Result_Proof(shuttle)
		logger.debug("ResultProof: "+str(self.result_proof)+"\n"+"OrderProof: "+str(self.order_proof));
		
		validTriggerSet=getValidTriggerSet("HEAD")
		# validTriggerSet.add("result_shuttle")
		triggerName = checkForPossibleFailure(client,validTriggerSet)
		logger.info("After checking for failures. triggerName : "+str(triggerName))
		if(triggerName!=None):
			shuttle=callFailureFunctionBasedOnTrigger(triggerName,shuttle, request_id, slot_number, operation)

		logger.info("PERFORM_OPERATION done at HeadReplica, transfering SHUTTLE to nextReplica : "+str(self.nextReplica))

		# logger.info("checking for failure injection")
		# shuttle = change_operation(shuttle, request_id, self.slot_number, operation)
		send(('FORWARD_SHUTTLE', request_id,shuttle,operation,self.slot_number,client), to=self.nextReplica)

	 #CONTROL FLOW: From (one Replica to another)
	def receive(msg=('FORWARD_SHUTTLE',request_id,shuttle,operation,slot,client), from_=self.prevReplica):
		logger.info("PERFORM_OPERATION SHUTTLE FORWARD. at "+str(self.currentReplica)+", from prevReplica : "+str(self.prevReplica)+", client: "+str(client)+", request_id: "+str(request_id)+", slot : "+str(slot)+", operation : "+str(operation))
		# logger.info("orderProof length  : "+str(len(self.order_proof))+", self.order_proof : "+str(self.order_proof));
		logger.debug("SHUTTLE : "+str(shuttle));
		flow = False
		if(slot>1):
			flow = checkSlotOperation(slot)
			logger.debug("the value for checkSlotOperation is " +str(flow))
		else:
			flow = True
		if(flow):
			if(validateOrderProof(shuttle,operation,slot)):
				# self.operation_result[request_id] = self.executeOperation(request_id, operation)
				self.operation_result_internal[request_id] = self.executeOperation(request_id, operation)
				updateSlotOperation(request_id,slot,operation)
				slot_number = slot
				tupl = self.getResult_Order_Proof(request_id,operation,slot_number)
				shuttle = self.updateShuttle(shuttle,tupl)
				logger.debug("shuttle after update: "+str(shuttle))
				self.updateOrder_Result_Proof(shuttle)
				#validation successful now sending the shuttle forward
				if(self.nextReplica == None):
					
					orderproof,resultproof = shuttle
					# logger.info("justfortest"+str(len(resultproof)))
					self.cacheResult(request_id, resultproof)
					#SENDING result to client
					logger.info('SHUTTLE reached at Tail : '+str(self.currentReplica)+", sending result to client : "+str(client)+", final dict object : "+str(self.dictionary_data)+", for operation : "+str(operation))
					handleRetransmissionCase()
					# resultproof 	=change_result(resultproof, request_id, operation)
					self.dictionary_data["operation"]=str(operation)
					########################################################################################################
					#CHECKING FOR FAILURE :  SHUTTLE COUNTER : SENDING TO CLIENT
					########################################################################################################
					self.counters[client]["shuttleCounter"] =self.counters[client]["shuttleCounter"]+1
					validTriggerSet=getValidTriggerSet("TAIL")
					triggerName = checkForPossibleFailure(client,validTriggerSet)
					logger.info("After checking for failures. triggerName : "+str(triggerName))
					if(triggerName!=None):
						logger.info("******************GOING INSIDE HOHO***************")
						shuttle=callFailureFunctionBasedOnTrigger(triggerName,shuttle, request_id, slot_number, operation)
						orderproof,resultproof=shuttle
					########################################################################################################
					#SENDING RESPONSE TO CLIENT
					send(('RESULT_FROM_TAIL',request_id, resultproof ,self.operation_result_internal[request_id],self.dictionary_data,self.currentReplica), to=client)
					

					#STARTING REVERSE SHUTTLE OPERATIONS
					logger.info('REVERSE_SHUTTLE starting. Forwarding to prevReplica : '+str(self.prevReplica))
					########################################################################################################
					#CHECKING FOR FAILURE : REVERSE SHUTTLE COUNTER : SENDING TO PREVIOUS REPLICA
					########################################################################################################
					self.counters[client]["resultShuttleCounter"] =self.counters[client]["resultShuttleCounter"]+1
					validTriggerSet=[]
					validTriggerSet.append("result_shuttle")#getValidTriggerSet("TAIL")
					triggerName = checkForPossibleFailure(client,validTriggerSet)
					logger.info("After checking for failures. triggerName : "+str(triggerName))
					if(triggerName!=None):
						shuttle=callFailureFunctionBasedOnTrigger(triggerName,shuttle, request_id, slot_number, operation)
					########################################################################################################
					orderproof,resultproof=shuttle
					send(('REVERSE_SHUTTLE', request_id, resultproof, self.operation_result_internal[request_id],client), to=self.prevReplica)
				else:
					self.counters[client]["shuttleCounter"] =self.counters[client]["shuttleCounter"]+1
					validTriggerSet=[]#getValidTriggerSet("NONHEAD")
					validTriggerSet.append("shuttle")
					triggerName = checkForPossibleFailure(client,validTriggerSet)
					logger.info("After checking for failures. triggerName : "+str(triggerName))
					orderproof,resultproof = shuttle
					if(triggerName!=None):
						shuttle=callFailureFunctionBasedOnTrigger(triggerName,shuttle, request_id, slot_number, operation)
					send(('FORWARD_SHUTTLE',request_id,shuttle,operation,slot,client), to=self.nextReplica)
			else:
				# NOTE: replica turns itself immutable and sends wedge statement to client with proof od misbehaviour
				logger.error("************************Validating order proof failed at replica : "+str(self.currentReplica)+", request_id : "+str(request_id))
		else:
			logger.error("There is inconsistency in the slots, all previous slot havent been used for execution********************")



	 #message to replca from previous 
	def receive(msg=('REVERSE_SHUTTLE',request_id,result_proof, res,client,), from_=self.nextReplica):
		# incrementCounter(client,"resultShuttleCounter")
		self.counters[client]["resultShuttleCounter"] =self.counters[client]["resultShuttleCounter"]+1
		logger.info("REVERSE_SHUTTLE received at replica : "+str(self.currentReplica)+", from nextReplica : "+str(self.nextReplica)+", request_id : "+str(request_id))
		validation = config.checkForResultConsistency(result_proof, res, self.allReplicaVerifyKeysMap)
		logger.info("the result from validation is " + str(validation))
		if(validation):
			self.cacheResult(request_id, result_proof)
			if(self.prevReplica == None):
				logger.info("SHUTTLE reached at HEAD")
			else:
				validTriggerSet=[]
				validTriggerSet.append("result_shuttle")
				triggerName = checkForPossibleFailure(client,validTriggerSet)
				if(triggerName!=None):
					shuttle=(None,result_proof)
					slot_number=self.requestIdToSoPair[request_id][0]
					operation=self.requestIdToSoPair[request_id][1]

					shuttle=callFailureFunctionBasedOnTrigger(triggerName,shuttle, request_id, slot_number, operation)
					orderproof,result_proof= shuttle
				logger.info("After caching result, forwarding to prevReplica : "+str(self.prevReplica))
				send(('REVERSE_SHUTTLE',request_id,result_proof, res,client,), to=self.prevReplica)
		else:
			logger.error("the validation failed at" + str(self.currentReplica))
			logger.error("************************Validating order proof failed at replica : "+str(self.currentReplica)+", request_id : "+str(request_id))


	#FROM NON-HEAD Replicas to HEAD Replica for Retransmission case
	def receive(msg=('RETRANSMISSION_HEAD',requestId,operation,fromReplica,client),):
		self.counters[client]["forwardRequestCounter"] =self.counters[client]["forwardRequestCounter"]+1
		logger.info("RETRANSMISSION_HEAD request received at HEAD replica : "+str(self.currentReplica)+" from replica : "+str(fromReplica))
		timeout = config.readProperty("head_timeout")
		#NOTE: change it to  : if(requestId in self.result_cache):	
		if(requestId in self.result_cache):	
			logger.info("RequestId found inside the cache. Returning response to client : "+client+", requestId : "+str(requestId))
			send(("RETRANSMISSION",self.result_cache[requestId],self.currentReplica), to=client)
			return;
		#HEAD has already started operation for the first request sent by other 
		#replicas(including head) in case it does not recognize the operation
		if((requestId in self.requestIdToSoPair) and (requestId not in self.result_cache)):
			logger.info("Result shuttle is yet to receive at the head, waiting for it!! fromReplica : "+str(fromReplica))
			if await(some(received(('REVERSE_SHUTTLE',requestId,result_proof,res,),from_=self.nextReplica),has= (requestId in self.result_cache))):
				logger.info("REACHED HEAD FROM SHUTTLE & RETRANSMISSION COMPLETE")
			elif(timeout(timeout)):
				logger.info("TIMEOUT at Replica : "+str(self.currentReplica)+" sending RECONFIGURATION request to Olympus!!!!")		
		else:
			#PERFORM Operation for FORWARD_SHUTTLE only once and stop for all other Replicas
			logger.info("Operation is not recognized at HeadReplica. requestId : "+str(requestId)+", operation : "+str(operation))
			send(("PERFORM_OPERATION",requestId,operation), to=self.headReplica)
			if(timeout(timeout)):
				logger.info("TIMEOUT at Replica : "+str(self.currentReplica)+" sending RECONFIGURATION request to Olympus!!!!")		
			

	#FROM Clients To Replicas
	def receive(msg=('RETRANSMISSION',requestId,operation,client,), from_=self.clients):
		logger.info("RETRANSMISSION received at "+str(self.currentReplica)+", requestId : "+str(requestId)+", operation : "+str(operation)+ ", from client : "+str(client))
		if(self.replica_state == 'IMMUTABLE'):
			# if("replica_2" in self.currentReplica):
			logger.info("Replica is in IMMUTABLE state. Returning ERROR to clients")
			send(("RETRANSMISSION","ERROR",self.currentReplica), to=client)
		#TEMPORARILY MADE NOT HERE, TO ALLOW NEXT CASE. REVERT IT TO : elif(requestId in self.result_cache):	
		elif(requestId in self.result_cache):	
			logger.info("RequestId found in replica cache. Returning to client : "+str(client))
			#TODO NOTE Handle Shuttle 
			send(("RETRANSMISSION",self.result_cache[requestId],self.currentReplica), to=client)

		else:#(self.currentReplica != self.headReplica):
			#send request to head
			#self.headReplica
			logger.info("RETRANSMISSION_HEAD to HEAD REPLICA currentReplica : "+ str(self.currentReplica))
			send(("RETRANSMISSION_HEAD",requestId,operation,self.currentReplica),to=self.headReplica)
			
			timeout=config.readProperty("nonhead_timeout")
			#check if the current replica is a tailReplica, if yes, it will get result shuttle from prevReplica else
			#all other shuttle will receive results from nextReplica
			logger.info("self.currentReplica : "+str(self.currentReplica)+", self.tailReplica : "+str(self.tailReplica))
			slot=int()
			shuttle=[]
			# if ((self.currentReplica==self.tailReplica) and await(some(received(('SHUTTLE','FORWARD',request_id,shuttle,operation,slot),from_=self.prevReplica)))) or await(some(received(('SHUTTLE','REVERSE',requestId,result_proof,),from_=self.nextReplica),has=requestId in self.result_cache)):
			
			if (self.currentReplica==self.tailReplica):
				if(await(some(received(('FORWARD_SHUTTLE',request_id,shuttle,operation,slot),from_=self.prevReplica)))):
					logger.info("in retransmission unrecognised request. Shuttle reached to tail node : "+str(result_proof)+", sending to client : "+str(client))
					send(('RETRANSMISSION', self.result_cache[requestId] ,self.currentReplica), to=client)
				elif(timeout(timeout)):
					logger.info("timer expired at tail replica : "+str(self.currentReplica))
			else:
				if await(some(received(('REVERSE_SHUTTLE',requestId,result_proof,res,),from_=self.nextReplica),has=requestId in self.result_cache)):
					logger.info("shuttle coming from next replica result_proof : "+str(result_proof)+", sending to client : "+str(client))
					send(('RETRANSMISSION', self.result_cache[requestId] ,self.currentReplica), to=client)
				elif(timeout(timeout)):
					logger.info("timer expired at non head replica : "+str(self.currentReplica))
					#TODO RECONFIGURATION
		
		#(msg,requestId,operation,replicaId):

	def run():
		await(received('',))

	def executeOperation(request_id,operation):
		logger.info("Executing Operation in dictonary. operation : "+str(operation)+", dict before : "+str(self.dictionary_data))
		temp=operation.split('(')
		result = ''
		if(temp[0]=="put"):
			tempsplit=operation.split('\'')
			dictionary_data[tempsplit[1]]=tempsplit[3]
			result='ok'

		elif(temp[0] == "append"):
			tempsplit=operation.split('\'')
			if(self.dictionary_data[tempsplit[1]]):	
				self.dictionary_data[tempsplit[1]] = self.dictionary_data[tempsplit[1]] + ' ' + tempsplit[3]
				logger.debug('append is executeed@@@@@@@@')
				result= 'ok'
			else:
				result= 'fail'

		elif(temp[0] == "get"):
			tempsplit=operation.split('\'')
			if(self.dictionary_data[tempsplit[1]]):
				value = self.dictionary_data[tempsplit[1]];
				result= value
				logger.debug('get is executeed@@@@@@@@')	
			else:
				result= ''

		elif(temp[0] == "slice"):
			logger.info("After Executing Operation in dictonary. "+", dict before : "+str(self.dictionary_data)+"slice")
			tempsplit=operation.split('\'')
			if(dictionary_data[tempsplit[1]]):
				ind  = tempsplit[3].split(':')
				if (len(dictionary_data[tempsplit[1]])) > int(ind[1]):
					dictionary_data[tempsplit[1]] = dictionary_data[tempsplit[1]][int(ind[0]):int(ind[1])]
					result= 'ok'
				else:
					result= 'fail'
			else:
				result= 'fail'
			logger.info("slice operation successfully executed")
		return result


	def cacheResult(request_id, resultproof):
		logger.info("cacheResult  request_id : "+str(request_id))
		self.result_cache[request_id] = resultproof

	def validateOrderProof(shuttle,operation,slot):
		logger.info("validateOrderProof. slot : %s, operation : %s"%(slot,operation))
		order,result = shuttle
		flag = True
		for i in range(0,len(order)):
			try:
				# Create a VerifyKey object from a hex serialized public key
				verify_key = nacl.signing.VerifyKey(self.allReplicaVerifyKeysMap[i], encoder=nacl.encoding.HexEncoder)
				logger.debug("order number"+str(i+1)+ "from shttle : "+ str(order[i]))
				message = order[i]
				# Check the validity of a message's signature
				# Will raise nacl.exceptions.BadSignatureError if the signature check fails
				Tuple = verify_key.verify(message)
				orderTuple = ast.literal_eval(Tuple.decode("utf-8"))
				# print("orderTuple as of now "+str(orderTuple)+" "+str(slot)+str(operation))
				logger.debug("validating this slot pair of orderproodf "+str())
				if(orderTuple != (slot,operation)):
					flag=False
					break
				logger.debug("verified")
			except nacl.exceptions.BadSignatureError:
				logger.error("key mismatch failed for ", order[i])
				return False
		return flag

	# def validateResultProof(resultproof):
	# 	for i in range(0,len(resultproof)):
	# 		length = len(resultproof)
	# 		try:
	# 			logger.debug("12345678908765432123456789876543234567987654323456789876543234567890987654", resultproof)
	# 			# Create a VerifyKey object from a hex serialized public key
	# 			verify_key = nacl.signing.VerifyKey(self.allReplicaVerifyKeysMap[1], encoder=nacl.encoding.HexEncoder)
	# 			logger.debug("result number",i+1, "from result proof", resultproof[length-i-1])
	# 			message = resultproof[length-i-1]
	# 			# Check the validity of a message's signature
	# 			# Will raise nacl.exceptions.BadSignatureError if the signature check fails
	# 			result = verify_key.verify(message)

	# 			logger.debug("verified")
	# 			actualResult = result.decode("utf-8")
	# 		except nacl.exceptions.BadSignatureError:
	# 			logger.error("key mismatch failed for ", resultproof[length-i-1])
	# 			return (False,None)
	# 	logger.info("validateResultProof. SUCCESSFULL!! ")
	# 	return (True,actualResult)

	def updateShuttle(shuttle,tupl):
		logger.debug("updateShuttle at Replica : "+str(self.currentReplica))
		order=[]
		result=[]
		orderproof, resultproof=tupl

		# self.order_proof.append((slot_number,operation))
		# self.result_proof.append((self.operation_result_internal[request_id],operation,'encrypted'))

		if(shuttle==None):
			order.append(orderproof)
			result.append(resultproof)
			shuttle=(order,result)
		else:
			shuttle[0].append(orderproof)
			shuttle[1].append(resultproof)

		return shuttle

	def signMessage(msg):
		signedMsg = currentReplicaSigningKey.sign(str.encode(msg))
		logger.debug("orignal message : "+str(msg)+", signedMsg : "+str(signedMsg))
		return signedMsg

	def getResult_Order_Proof(request_id,operation,slot_number):
		logger.debug("inside getResult_Order_Proof function for creating the current tuple")
		order = (slot_number,operation)
		signedOrderProof= signMessage(str(order))
		encryptedHash = config.calculateHash(self.operation_result_internal[request_id])
		result = (self.operation_result_internal[request_id],operation,encryptedHash)
		signedResultProof = signMessage(str(result))
		tupl = (signedOrderProof,signedResultProof)
		# tupl = (str(order),str(result))
		return tupl

	def updateOrder_Result_Proof(shuttle):
		logger.info("updating OrderProof and ResultProof !!")
		if(shuttle==None):
			logger.info('Updating HEAD Replica')
		else:
			oProof, rProof = shuttle
			for i in oProof:
				self.order_proof.append(i)
			for j in rProof:
				self.result_proof.append(j)

		# logger.info("the updated orderproof"+str(self.order_proof))
	def checkSlotOperation(slot):
		index =self.replicas.index(self.currentReplica)
		verify_key = nacl.signing.VerifyKey(allReplicaVerifyKeysMap[index], encoder=nacl.encoding.HexEncoder)
		# logger.debug("result number",i+1, "from result proof", resultproof[length-i-1])
		message = self.order_proof[len(self.order_proof)-1]
		# Check the validity of a message's signature
		# Will raise nacl.exceptions.BadSignatureError if the signature check fails
		result = verify_key.verify(message)

		# # logger.debug("verified")
		actualResult = ast.literal_eval(result.decode("utf-8"))
		s,o =actualResult
		if(s == slot - 1):
			logger.debug("the slots are consistent")
			return True
		else:
			logger.debug("there is inconsistency among slots")
			return False

	
	def handleRetransmissionCase():
		retransmission_case_replica_sleep_time=config.readProperty('retransmission_case_replica_sleep_time')
		if(retransmission_case_replica_sleep_time > 0):
			logger.info("sleeping for "+str(retransmission_case_replica_sleep_time)+", to mock retransmission case.")
			time.sleep(retransmission_case_replica_sleep_time)

	def callFailureFunctionBasedOnTrigger(triggerName,shuttle, request_id, slot_number, operation):
		# 'client_request', 'forwarded_request', 'shuttle', 'result_shuttle'
		logger.info("callFailureFunctionBasedOnTrigger trying triggerName : "+str(triggerName)+" request_id : "+str(request_id))
		if(triggerName == "change_operation"):
			return change_operation(shuttle, request_id, slot_number, operation)
			# logger.info("1. callFailureFunctionBasedOnTrigger triggerName : "+str(triggerName))
		elif(triggerName == "change_result"):
			return change_result(shuttle, request_id, operation)
			# logger.info("2. callFailureFunctionBasedOnTrigger triggerName : "+str(triggerName))
		if(triggerName == "drop_result_stmt"):
			# drop_result_stmt()
			return drop_result_stmt(shuttle)

	def checkForPossibleFailure(client,validTriggerSet):
		logger.info("Checking for possible failures. Current counter : "+str(self.counters)+", self.failureDS : "+str(self.failureDS))
		if(self.failureDS == None or len(self.failureDS)==0) :
			return
		replicaIndex = self.replicas.index(self.currentReplica)
		currentConfiguration = 0
		failureDsReplicaDict = self.failureDS[currentConfiguration]["replica"]
		if(replicaIndex not in failureDsReplicaDict):
			return None
		failureLists = self.failureDS[currentConfiguration]["replica"][replicaIndex]
		for obj in failureLists:
			triggerName = obj["triggerName"]
			clientObj = obj["client"]
			if(clientObj == None):
				return None
			messageNumber=obj["messageNumber"]
			triggerFailure=obj["triggerFailure"]
			if(clientObj != self.clients.index(client)):
				continue
			if(triggerName not in validTriggerSet):
				continue
			if(self.counters[client]["directRequestCounter"] == messageNumber and triggerName=="client_request"):
				# callFailureFunctionBasedOnTrigger(triggerFailure)
				return triggerFailure
			elif(self.counters[client]["forwardRequestCounter"] == messageNumber and triggerName=="forwarded_request"):
				# callFailureFunctionBasedOnTrigger(triggerFailure)
				return triggerFailure
			elif(self.counters[client]["shuttleCounter"] == messageNumber and triggerName=="shuttle"):
				# callFailureFunctionBasedOnTrigger(triggerFailure)
				return triggerFailure
			elif(self.counters[client]["resultShuttleCounter"] == messageNumber and triggerName=="result_shuttle"):
				# callFailureFunctionBasedOnTrigger(triggerFailure)
				return triggerFailure
		return None

	def change_operation(shuttle, requestId, slot, operation ):
		#just before tsending the shuttle
		logger.info("Change operation called with shuttle" + "  requestId: "+ str(requestId) +"operation : "+ str(operation))
		order, result = shuttle
		lorder = len(order)
		lresult = len(result)
		print("length of oreder"+str(len(order)))
		order = order[0:lorder-1]
		print("length of oreder"+str(len(order)))
		result =  result[0:lresult-1]
		orderStmt = (slot, "get('x')")
		resultStmt = (operation_result_internal[requestId], operation, config.calculateHash(operation_result_internal[requestId]))
		signedOrderProof= signMessage(str(orderStmt))
		signedResultProof = signMessage(str(resultStmt))
		order.append(signedOrderProof)
		print("length of oreder"+str(len(order)))
		result.append(signedResultProof)
		shuttle = (order,result)
		logger.debug("change shuttle"+ str(shuttle))

		return shuttle

	def change_result(shuttle, requestId, operation):

		logger.info("Change result called with resultproof" + "  requestId: "+ str(requestId) +"operation : "+ str(operation))
		order, resultproof = shuttle
		# lorder = len(order)
		lresult = len(resultproof)
		print("length of resultproof"+str(len(resultproof)))
		# orderStmt = (slot, "get('x')")
		resultStmt = (operation_result_internal[requestId], operation, config.calculateHash('OKayy'))
		print("this is the bugged statement : ",resultStmt)
		# signedOrderProof= signMessage(str(orderStmt)
		signedResultProof = signMessage(str(resultStmt))
		resultproof =  resultproof[0:lresult-1]
		# order[lorder] = signedOrderProof
		resultproof.append(signedResultProof)
		return (order, resultproof)
		# shuttle = (order,signedResultProof)
		# for i in Res

	def drop_result_stmt(shuttle):
		order, result = shuttle
		result = result[1:]
		return (order,result)






